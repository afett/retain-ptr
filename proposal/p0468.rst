retain_ptr constructors
^^^^^^^^^^^^^^^^^^^^^^^

``retain_ptr (pointer p, retain_object_t) noexcept(maybe);``

  :effects: Constructs a ``retain_ptr`` that retains ``p``, initializing the
            stored pointer with ``p``, and increments the reference count of
            ``p`` if ``p != nullptr``.
  :postconditions: ``get() == p``.
  :remarks: This constructor is only specified ``noexcept`` if
            ``traits_type::increment`` function is also specified ``noexcept``.
            If an exception is thrown during this operation, this constructor
            will have no effect.

``retain_ptr (pointer p, adopt_object_t) noexcept;``

  :effects: Constructs a ``retain_ptr`` that adopts ``p``, initializing the
            stored pointer with ``p``.
  :postconditions: ``get() == p``
  :remarks: ``p``'s reference count remains untouched

``explicit retain_ptr (pointer p) noexcept(maybe);``

  :effects: Constructs a ``retain_ptr`` by delegating to another ``retain_ptr``
            constructor via ``traits_type::default_action``. If
            ``traits_type::default_action`` does not exist, ``retain_ptr`` is
            constructed as if by ``retain_ptr(p, adopt_object_t)``.
  :postconditions: ``get() == p``
  :remarks: This constructor is only specified ``noexcept`` if the delegated
            constructor is also specified ``noexcept``.

``retain_ptr () noexcept;``

  :effects: Constructs a ``retain_ptr`` object that retains nothing,
            value-initializing the stored pointer.
  :postconditions: ``get() == nullptr``

``retain_ptr(retain_ptr const& r) noexcept(maybe);``

  :effects: Constructs a ``retain_ptr`` by extending management from ``r`` to
            ``*this``.
  :postconditions: ``get() == r.get()``
  :remarks: This constructor is only specified ``noexcept`` if
            ``traits_type::increment`` function is specified ``noexcept``.
            If an exception is thrown during this operation, this constructor
            will have no effect.

``retain_ptr(retain_ptr&& r) noexcept;``

  :effects: Constructs a ``retain_ptr`` by transferring management from ``r``
            to ``*this``.
  :postconditions: ``get()`` yields the value ``r.get()`` yielded before the
                   construction.

retain_ptr destructor
^^^^^^^^^^^^^^^^^^^^^

``~retain_ptr() noexcept(maybe);``

  :effects: If ``get() == nullptr``, there are no effects. Otherwise,
            ``traits_type::decrement(get())``.
  :remarks: This destructor is only specified ``noexcept`` if the
            ``traits_type::decrement`` function is specified ``noexcept``

retain_ptr assignment
^^^^^^^^^^^^^^^^^^^^^

``retain_ptr& operator = (retain_ptr const& r) noexcept(maybe);``

  :effects: Extends ownership from ``r`` to ``*this`` as if by calling
            ``reset(r.get(), retain)``.
  :returns: ``*this``
  :remarks: This operator is only specified ``noexcept`` if both
            ``traits_type::increment`` and ``traits_type::decrement`` functions
            are specified ``noexcept``.

``retain_ptr& operator = (retain_ptr&& r) noexcept;``

  :effects: Transfers ownership from ``r`` to ``*this`` as if by calling
            ``reset(r.detach())``
  :returns: ``*this``

``retain_ptr& operator = (nullptr_t) noexcept;``

  :effects: ``reset()``
  :postconditions: ``get() == nullptr``
  :returns: ``*this``

retain_ptr observers
^^^^^^^^^^^^^^^^^^^^

``element_type& operator * () const noexcept;``

  :requires: ``get() != nullptr``
  :returns: ``*get()``

``pointer operator -> () const noexcept;``

  :requires: ``get() != nullptr``
  :returns: ``get()``
  :note: use typically requires that ``element_type`` be a complete type.

``pointer get () const noexcept;``

  :returns: The stored pointer

``explicit operator pointer () const noexcept;``

  :returns: ``get()``

``explicit operator bool () const noexcept;``

  :returns: ``get() != nullptr``

``long use_count () const noexcept(maybe);``

  :returns: Value representing the current reference count of the stored
            pointer. If ``traits_type::use_count(get())`` is not a valid
            expression, ``-1`` is returned. If ``get() == nullptr`` ``0`` is
            returned
  :remarks: This observer is only specified ``noexcept`` if
            ``traits_type::use_count`` is specified ``noexcept``. Unless otherwise
            specified, the value returned should be considered stale.

``bool unique () const noexcept(maybe);``

  :returns: ``use_count() == 1``
  :remarks: This observer is only specified ``noexcept`` if
            ``traits_type::use_count`` is specified ``noexcept``. Unless otherwise
            specified, the value returned should be considered stale.

retain_ptr modifiers
^^^^^^^^^^^^^^^^^^^^

``[[nodiscard]] pointer detach () noexcept;``

  :postcondition: ``get() == nullptr``
  :returns: The value ``get()`` had at the start of the call to ``detach``

``void reset (pointer p, retain_object_t) noexcept(maybe);``

  :effects: Assigns ``p`` to the stored pointer, and then if the old value of
            the stored pointer ``old_p``, was not equal to ``nullptr``, calls
            ``traits_type::decrement``. Then if ``p`` is not equal to
            ``nullptr``, ``traits_type::increment`` is called.
  :postconditions: ``get() == p``
  :remarks: This modifier is only specified ``noexcept`` if both
            ``traits_type::decrement`` and ``traits_type::increment`` are
            specified ``noexcept``.

``void reset (pointer p, adopt_object_t) noexcept(maybe);``

  :effects: Assigns ``p`` to the stored pointer, and then if the old value of
            the stored pointer, ``old_p``, was not equal to ``nullptr``, calls
            ``traits_type::decrement``.
  :postconditions: ``get() == p``
  :remarks: This modifier is only specified ``noexcept`` if
            ``traits_type::decrement`` is specified ``noexcept``.

``void reset (pointer p = pointer { }) noexcept(maybe);``

  :effects: Delegates assignment of ``p`` to the stored pointer via
            ``reset(p, traits_type::default_action())``.
  :postconditions: ``get() == p``
  :remarks: This modifier is only specified ``noexcept`` if the delegated
            ``reset`` function called is also specified ``noexcept``.

``void swap (retain_ptr& r) noexcept;``

  :effects: Invokes ``swap`` on the stored pointers of ``*this`` and ``r``.
